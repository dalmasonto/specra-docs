---
title: Leistung & Entwicklung
description: Verstehen Sie die Leistungsoptimierungen und Entwicklungsfunktionen, die in das Dokumentationssystem integriert sind
order: 7
icon: zap
---

## Caching-System

### In-Memory Caching

Das System verwendet eine intelligente Caching-Schicht f√ºr teure Dateisystemoperationen:

- **Versionslisten-Caching**: Gecached f√ºr 5 Sekunden in Dev, 60 Sekunden in Produktion
- **Dokumentlisten-Caching**: Pro-Version-Caching mit automatischer Invalidierung
- **Einzel-Dokument-Caching**: Geschl√ºsselt nach Version und Slug

Der Cache wird automatisch invalidiert, wenn sich MDX- oder Konfigurationsdateien im Entwicklungsmodus √§ndern.

### Cache-Statistiken

Im Entwicklungsmodus werden Cache-Operationen in der Konsole protokolliert:

```
‚úÖ [Cache] hit: getAllDocs:v1.0.0
‚ùå [Cache] miss: getDocBySlug:v1.0.0:configuration
‚è±Ô∏è  getDocBySlug(configuration): 45.23ms
```

## Hot Reload

### Echtzeit-Updates

Das System √ºberwacht Ihr `docs/`-Verzeichnis auf √Ñnderungen und aktualisiert die Seite automatisch, wenn Sie speichern:

- √úberwacht `.mdx`-Dateien auf Inhalts√§nderungen
- √úberwacht `_category_.json`-Dateien auf Navigations-Updates
- Verwendet Server-Sent Events (SSE) f√ºr effiziente Kommunikation
- Nur im Entwicklungsmodus aktiv

### Wie es funktioniert

1. Datei-Watcher √ºberwacht das `docs/`-Verzeichnis rekursiv
2. Wenn sich eine Datei √§ndert, sendet die API ein Ereignis an den Browser
3. Der Browser l√∂st eine weiche Aktualisierung aus, um den Inhalt neu zu laden
4. Cache wird f√ºr betroffene Dateien invalidiert

## Statische Generierung

### Optimierter Build-Prozess

Der Build-Prozess verwendet zwischengespeicherte Daten, um `generateStaticParams` zu beschleunigen:

```typescript
export async function generateStaticParams() {
  const versions = getCachedVersions()  // Gecached
  const params = []

  for (const version of versions) {
    const docs = await getCachedAllDocs(version)  // Gecached
    for (const doc of docs) {
      params.push({
        version,
        slug: doc.slug.split("/").filter(Boolean),
      })
    }
  }

  return params
}
```

### Leistungstipps

F√ºr gro√üe Dokumentationsseiten (1000+ Dateien):

1. **Ordnerorganisation verwenden**: Organisieren Sie Dokumente in logische Ordner, um die Cache-Lokalit√§t zu verbessern
2. **Entwurfsmodus aktivieren**: Markieren Sie unvollst√§ndige Dokumente mit `draft: true`, um sie von Produktions-Builds auszuschlie√üen
3. **Bilder optimieren**: Verwenden Sie Next.js Image-Optimierung f√ºr Screenshots und Diagramme
4. **Build-Zeiten √ºberwachen**: Beobachten Sie die Leistungsprotokolle w√§hrend der Entwicklung

## Entwicklungsmodus-Funktionen

### Leistungsprotokollierung

Wenn Sie `npm run dev` ausf√ºhren, sehen Sie detaillierte Leistungsmetriken:

```
‚è±Ô∏è  getAllDocs(v1.0.0): 234.56ms
‚è±Ô∏è  getDocBySlug(getting-started): 12.34ms
üíæ Memory Usage: { rss: '156MB', heapTotal: '89MB', heapUsed: '67MB' }
```

### Debug-Dienstprogramme

Das System enth√§lt hilfreiche Debugging-Tools (nur Dev-Modus):

- **PerfTimer**: Dauer von Operationen messen
- **logCacheOperation**: Cache-Treffer/Fehlschl√§ge verfolgen
- **logMemoryUsage**: Speichernutzung √ºberwachen
- **debugLog**: Komplexe Objekte sch√∂n drucken

## Produktionsoptimierungen

### Statische Seitenerstellung (SSG)

Alle Dokumentationsseiten werden zur Build-Zeit vorgerendert:

- Null Server-Side Rendering Overhead
- Sofortige Seitenladezeiten
- Exzellente SEO-Leistung
- CDN-freundliche statische Assets

### Bundle-Optimierung

- Server-Komponenten standardm√§√üig (minimales JavaScript)
- Client-Komponenten nur wo n√∂tig (Tabs, Theme-Switcher)
- Automatisches Code-Splitting pro Route
- Tree-Shaking von ungenutzten Abh√§ngigkeiten

## Leistung √ºberwachen

### Build-Analyse

√úberwachen Sie Ihre Build-Ausgabe auf Leistungserkenntnisse:

```bash
npm run build
```

Achten Sie auf:
- Generierungszeit statischer Seiten
- Anzahl generierter Seiten
- Warnungen zur Bundle-Gr√∂√üe

### Entwicklungsmetriken

Beobachten Sie w√§hrend der Entwicklung die Konsole auf:
- Cache-Treffer/Fehlschlag-Verh√§ltnisse (sollten sich mit der Zeit verbessern)
- Dateioparationszeiten (langsame Operationen identifizieren)
- Speichernutzungsmuster (Speicherlecks erkennen)

## Best Practices

1. **Dateien organisiert halten**: Logische Ordnerstruktur verbessert Caching
2. **Frontmatter weise nutzen**: Nur notwendige Metadaten hinzuf√ºgen
3. **Inhalte optimieren**: Gro√üe Dateien (>1MB) sollten aufgeteilt werden
4. **Cache √ºberwachen**: Hohe Fehlraten weisen auf Caching-Probleme hin
5. **Saubere Builds**: Gelegentlich `.next/` f√ºr frische Builds l√∂schen

## Fehlerbehebung

### Langsame Build-Zeiten

Wenn Builds langsam sind:

1. Pr√ºfen Sie auf extrem gro√üe MDX-Dateien (>5MB)
2. Reduzieren Sie die Anzahl der gleichzeitig generierten Seiten
3. Cache leeren: `.next/` und `node_modules/.cache/` l√∂schen
4. Abh√§ngigkeiten auf neueste Versionen aktualisieren

### Hot Reload funktioniert nicht

Wenn √Ñnderungen nicht reflektiert werden:

1. Pr√ºfen Sie, ob Sie im Entwicklungsmodus sind (`npm run dev`)
2. Suchen Sie nach Fehlern in der Browser-Konsole
3. √úberpr√ºfen Sie, ob der `/api/mdx-watch` Endpunkt antwortet
4. Hard Refresh des Browsers (Cmd+Shift+R oder Ctrl+Shift+R)

### Speicherprobleme

Bei hoher Speichernutzung:

1. Pr√ºfen Sie auf Zirkelbez√ºge in der Dokumentation
2. √úberwachen Sie die Cache-Gr√∂√üe mit `getCacheStats()`
3. Reduzieren Sie `CACHE_TTL` in `lib/mdx-cache.ts`
4. Leeren Sie Caches manuell mit `clearAllCaches()`
